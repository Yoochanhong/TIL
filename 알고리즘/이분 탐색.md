# Binary Search



### 이분 탐색?

1~100까지 랜덤으로 생성된 숫자를 맞춘다고 한다면, 어떻게 하는게 가장 효율적일까?

<img src = "https://velog.velcdn.com/images/godeok24/post/3a510c10-7f24-4456-98c8-cc2fd4d02333/image.png" width=600px/> 

1, 2, 3.... 이런식으로 하나씩 맞추는것보다 숫자가 있을만한 구간을 줄여가며 찾는것이 가장 효율적일 것이다.

이처럼 범위를 줄여나가면서 원하는 데이터를 찾는 기법을 **이분 탐색** 이라고 한다.



### 시간 복잡도

이분 탐색에서 최악의 경우는 범위를 줄이고 줄여서 마지막으로 하나의 데이터만 남았을 경우이다.

Ex) 1~100중 33을 골랐을 경우 : 50 => 25 => 37 => 31 => 34 => 32 => 33

전체 데이터의 갯수를 n개라고 했을 때, 이분 탐색을 실행할때마다 범위가 1/2씩 줄어든다.

n * 1/2 * 1/2 * 1/2 .....

a번째 탐색을 실행했을때는 시간 복잡도는 (1/2)ª * n가 될 것이다.

최악의 경우에는 a번째 탐색했을때 범위가 1일때이므로 (1/2)ª * n = 1,

양변에 2ª를 곱해서  n = 2ª,

지수만 빼주기 위해 log₂를 양변에 취해주면 a = log₂n

a는 탐색 횟수이기 때문에 아무리 범위가 크더라도 log₂n 상한선을 뚫을 수 없게 된다.

그러므로 이분 탐색의 시간 복잡도는 O(log₂n)이다.



### 예제 코드

이분탐색은 형식이 정해져있기 때문에 아래의 코드를 조금씩 변형해서 사용하곤 한다.

``````c
int n = 100, target = 33;

int start = 1; end = n;

while(start < end){
  int mid = (start + end) / 2;
  if (mid < target) start = mid + 1;
  else if (mid > target) end = mid - 1;
  else {
    printf("찾음");
    break;
  }
}
``````

start와 end변수는 찾고자 하는 구간의 양 끝을 가리킨다.

mid는 start와 end를 더하고 2로 나눈 중앙값으로, mid 와 target을 비교하며 범위를 탐색한다.

만약 mid가 target보다 높으면 mid 위쪽은 아예 탐색할 필요가 없어지므로 end(구간의 끝)를 mid - 1로 바꿔준다.

반대로 mid가 target보다 낮으면 mid 아래쪽도 볼 필요가 없어지므로 start(구간의 시작)를 mid + 1로 바꿔준다.

마지막으로 mid와 target이 일치하면 반복문을 종료시킨다.



만약 반복문의 횟수를 묻는 문제가 나온다면 count 변수를 만들어서 돌때마다 count++을 해준다던가,,

배열 안의 값을 찾는 문제면 array[mid]와 같이 사용 할 수 있다.



### 주의할 점

1. 이분 탐색을 사용할때는 구간의 양 끝점을 기준으로 중앙값을 찾기 때문에, 찾고자 하는 구간이 **정렬**되어있음을 전제 조건으로 한다.
2. 반복문의 조건식으로 start <= end와 start < end가 올 수 있는데, 범위의 끝을 탐색한다 vs 안한다 의 차이점을 가지고 있다.

이정도만 알고 있어도 이분 탐색 문제를 푸는데는 지장이 없을거라고 생각한다 ^_^