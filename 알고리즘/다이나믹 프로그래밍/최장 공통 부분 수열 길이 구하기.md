## Longest Common Subsequence

여러개의 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열중 가장 긴 수열을 찾는 문제이다.



문자열 A  = "ACAYKP"

문자열 B  = "CAPCAK"

두 문자열의 LCS의 길이는 4, LCS는 "ACAK" 라고 할수 있다. 



### 점화식

<img src = "https://wikimedia.org/api/rest_v1/media/math/render/svg/a40feb09ada8db5fb1fb6fe0c31b2ee25b7c9835"/> 

만약 i가 0이거나 j가 0이라면 (비어있는 문자열과 문자열을 비교한다면) 0을,

두 문자와 문자가 같다면 LCS[ i ] [ j ] = LCS[i - 1] [ j - 1] + 1 을,

만약 다르다면 max(LCS[ i ] [ j - 1], LCS[ i - 1 ] [ j ])를 해주게 된다.

어떻게 이런 식이 나올 수 있는지 LCS를 직접 구해보며 알아보자.



### LCS 구하기

두 문자열의 LCS를 찾는다고 할 때, 아래와 같은 표로 탐색을 시작 할 수 있다.

|      |  0   |  A   |  C   |  A   |  Y   |  K   |  P   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
|  C   |  0   |      |      |      |      |      |      |
|  A   |  0   |      |      |      |      |      |      |
|  P   |  0   |      |      |      |      |      |      |
|  C   |  0   |      |      |      |      |      |      |
|  A   |  0   |      |      |      |      |      |      |
|  K   |  0   |      |      |      |      |      |      |

LCS는 0번째 원소도 사용해야 하기 때문에 편의상 초기값은 0으로 두고 시작한다. (이유는 나중에 알려줌!)

그 다음부터는 왼쪽에 있는 문자가 하나씩 있는지 없는지 대조하면서 숫자를 늘려간다.

|      |  0   |  A   |  C   |  A   |  Y   |  K   |  P   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
|  C   |  0   |  0   |  1   |      |      |      |      |
|  A   |  0   |      |      |      |      |      |      |
|  P   |  0   |      |      |      |      |      |      |
|  C   |  0   |      |      |      |      |      |      |
|  A   |  0   |      |      |      |      |      |      |
|  K   |  0   |      |      |      |      |      |      |

열에 있는 문자와 행에 있는 문자가 같기때문에 두 문자가 아예 없을때의 값인 "A"와 0일때의 값에서 1을 더해준다.

|      |  0   |  A   |  C   |  A   |  Y   |  K   |  P   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
|  C   |  0   |  0   |  1   |  1   |  1   |  1   |  1   |
|  A   |  0   |      |      |      |      |      |      |
|  P   |  0   |      |      |      |      |      |      |
|  C   |  0   |      |      |      |      |      |      |
|  A   |  0   |      |      |      |      |      |      |
|  K   |  0   |      |      |      |      |      |      |

그 이후부터는 전에 있던 값을 계속 가지고 간다.

AC와 C의 LCS는 C이지만, ACA와 C의 LCS도 C이고, ACAY와 C의 LCS도 C이기 때문이다.

|      |  0   |  A   |  C   |  A   |  Y   |  K   |  P   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
|  C   |  0   |  0   |  1   |  1   |  1   |  1   |  1   |
|  A   |  0   |  1   |  1   |  2   |      |      |      |
|  P   |  0   |      |      |      |      |      |      |
|  C   |  0   |      |      |      |      |      |      |
|  A   |  0   |      |      |      |      |      |      |
|  K   |  0   |      |      |      |      |      |      |

ACA와 CA의 LCS는 CA이다. 하지만 AC와 C의 LCS는 C이고 이것은 각 문자열에 A를 붙인것과 같다.

그러므로 AC와 C의 LCS의 길이에서 + 1 한것과 동일하다.

여기서 "LCS[ i ] [ j ] = LCS[ i - 1] [ j - 1] + 1" 라는 식을 도출 할 수 있다.

왼쪽 대각선 방향의 값에서 1을 더해주는 것이기 때문에 첫번째로 LCS가 성립하는 순간이 온다면, 왼쪽 대각선 방향에 값이 존재해야 할 것이다.

이를 위해 우선 0으로 마진설정을 해주는 것이다. (NULL + 1은 성립이 불가능하기 때문에)

계속 이어서 LCS를 구해준다.

|      |  0   |  A   |  C   |  A   |  Y   |  K   |  P   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
|  C   |  0   |  0   |  1   |  1   |  1   |  1   |  1   |
|  A   |  0   |  1   |  1   |  2   |  2   |  2   |  2   |
|  P   |  0   |  1   |  1   |  2   |      |      |      |
|  C   |  0   |      |      |      |      |      |      |
|  A   |  0   |      |      |      |      |      |      |
|  K   |  0   |      |      |      |      |      |      |

아까는 값을 계속 가지고 간다고 말하긴 했지만, 사실 값을 결정하는 부분에도 규칙이 있다.

ACA와 CAP의 LCS는 AC와 CA에 각각 A와 P를 붙여준 것과 같다.

만약 A를 붙여준다면 ACA와 CA의 LCS를, P를 붙여준다면 AC와 CAP를 보게 되는 것 이다.

최장 공통 부분 수열은 연속성을 띄고 있지 않기 때문에 겹치는 문자가 존재만 한다면 LCS의 길이가 올라가게 된다.

그래서 ACA와 CAP의 LCS는 ACA와 CA의 LCS, AC와 CAP의 LCS중 최대값을 가져가는 것이다.

점화식에 있던 "LCS[ i ] [ j ] = max(LCS[ i ] [ j - 1], LCS[ i - 1 ] [ j ])"라는 식을 여기서 도출 할 수 있다.

편리하게 생각하면 지금 있는 위치에서 위에 있는 값과 왼쪽에 있는 값중 최대값을 넣으면 된다!

|      |  0   |  A   |  C   |  A   |  Y   |  K   |  P   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
|  C   |  0   |  0   |  1   |  1   |  1   |  1   |  1   |
|  A   |  0   |  1   |  1   |  2   |  2   |  2   |  2   |
|  P   |  0   |  1   |  1   |  2   |  2   |  2   |  3   |
|  C   |  0   |  1   |  2   |  2   |  2   |  2   |  3   |
|  A   |  0   |  1   |  2   |  3   |  3   |  3   |  3   |
|  K   |  0   |  1   |  2   |  3   |  3   |  4   |  4   |

마지막으로 모든 값을 채워넣으면 ACAYKP와 CAPCAK의 LCS의 길이는 4라는 것을 알 수 있게 된다.



### 코드로 나타내기

<img src = "https://search.pstatic.net/common/?src=http%3A%2F%2Fblogfiles.naver.net%2FMjAyMDEwMzFfOTkg%2FMDAxNjA0MTM2ODgyOTg3.LhgE13qQl6z_D0nEIVyhG7g6nzp_tkLjBPcwU8DCvggg.Ui00zGdjQop_IeN7BDkSXhAwCkzcSwwo8TN5ncJ_alkg.PNG.kanjw950717%2Fimage.png&type=sc960_832" width=800px/> 

 

LCS의 개념을 그대로 적용하면 풀 수 있는 9251번 문제의 코드를 보며 이해해보자 

<a href ="https://www.acmicpc.net/problem/9251">백준 9251번 풀어보기</a>











```c
#include <stdio.h>
#include <string.h>

int max(int a, int b) { return a > b ? a : b; }

int main() {
    int lcs[1001][1001] = {0};
    char arr[1001], arr1[1001];
    scanf("%s %s", arr, arr1);
    int len = strlen(arr), len1 = strlen(arr1);
    for (int i = 1; i <= len; i++) {
        for (int j = 1; j <= len1; j++) {
            if (arr[i - 1] == arr1[j - 1]) lcs[i][j] = lcs[i - 1][j - 1] + 1;
            else dp[i][j] = max(lcs[i - 1][j], lcs[i][j - 1]);
        }
    }
    printf("%d", lcs[len][len1]);
    return 0;
}
```

1. 각 char 배열에 문자열을 입력받는다.
2. 각 문자열의 길이를 strlen으로 알아낸다.
3. 이중 for문을 돌면서 문자 하나하나를 비교한다.
   1. 여기서는 if문 안에있는 조건이 두 문자가 같을때이다. 그러므로 lcs배열의 [ i - 1 ] [ j - 1] + 1 한 값을 넣어준다.
   2. 만약 아니라면 두 문자의 값이 다르므로 왼쪽에 있는 값과 위에 있는 값중 최대값을 넣어준다.
4. 마지막으로 lcs 배열의 마지막 부분을 출력해주면 lcs의 길이가 완성된다.



### 어째서 성립할까?

lcs의 값은 좌표상 더 이전에 있던 lcs의 값을 참조하고 그 값들을 이용하지만,결국 현재 위치에 있는 lcs도 더 이후에 있을 lcs에게는 참조의 대상이 된다.

lcs를 타고타고 내려가다 보면 결국은 마진을 맞추기 위한 0과 0의 비교부터 시작하기 때문에 그 값을 이용해 더해진 값들은 쪼갠 문제에서의 정답에 영향을 받게 된다.

다이나믹 프로그래밍의 두 조건인 최적 부분 구조와 중복된 하위 문제들을 모두 갖추고 있기 때문에 lcs도 dp의 일종이라고 할 수 있다.
