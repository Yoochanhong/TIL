recode class

switch
break문 삭제
case에 Logical operator 사용 가능


Flutter (Heart) embedded - 박제창

임베디드 시스템에 관심이 있나요?

생활속에 있는거 => 임베디드 시스템

특별한 목적으로 만들어진 하나의 독립적인 시스템

애플 M1, M2도 임베디드

아두이노는 임베디드일까?

tmi = 10년만에 개정판 나옴

MCU와 임베디드의 차이

MCU는 디스플레이를 띄우기 어렵다

라즈베리파이는 클럭속도가 높아서 HTML 통신이 가능함

아두이노나 라베파에서 플러터 사용이 되나요? ㅆㄱㄴ


플러터 임베는 일본에서 많이 보인다.

토요타나 소니 등등

토요타는 리눅스 기반으로 자기들 차에 넣어서 사용하고 있다

플러터로 함 ^_^


라즈베리 파이
1. 가격
2. 리눅스 베이스 OS 설치 가능
3. SD카드 속도 및 그 외 이슈



라즈베리 파이 준비하기

12개 는 다 구비할것

DSI LCD Display

ML을 하고싶다면  CSI 또는 camera usb 준비하기

Model 4로 준비하려면

HDMI, C타입 전원 어댑터, mirce b - c 케이블을 더 준비하자


하드웨어 세팅 및 결합하기
sdcard 초기화
os 설치하기
전원 인가 및 부팅 확인하기


플러터 설치하기 => 데비안이라 리눅스 데스크탑이랑 똑같음


플러터의 임베더 계층에서 셋업을 하기때문ㅔ 여기에 윈도우 메니저, 커널 등ㄷ등이 다 들어있다.

GPIO



Widget book 페이지의 widget 스크랩하기 - 유병욱

what is widgetBook?

단순한 라이브러리임.

개발자의 피그마라고 보면 편함

프론트에서는 스토리북이라고 부름. 그거보고 좋아보여서 만들기 시작함


why use widgetBook?

위젯북이 모든 상황에 필요한 것은 아니다.

모든 프레임웤이나 라이브러리, 툴도 개발자가 필요하면 쓰는것이다.

위젯북을 효과적으로 쓸 수 있는 시점

기획 / 디자인 등의 타 직군과 UI / 디자인 관련 회의가 지나치게 길어질 경우가 많을때

각 상황에 맞는 UI 디버깅을 빠르고 간편하게 처리할 필요가 있을 때

동일 포지션의 개발자가 많아서 만들어진 위젯에 대해 설명이나 어떻게 쓰는지 공유가 필요한 경우

디자인 / 개발에서 동일하게 만들었는데 실제 완료된 UI는 뭔가 미묘하게 달라지는 경우

예전에 만든 위젯에 대한 활용법이나 개발 의도가 혼동될경우

불필요한 위젯 설계 시간을 줄이거나 중복 개발을 줄일 필요가 있는 경우


how to use widgetBook?

pubdev에 위젯북 치면 나옴

모바일은 좀 작아서 안씀

어지간하면 데탑앱으로 배포함


try it widgetBook!

디자인 시스템과 함께 사용할 수 있음.

domain의 testing정도는 목업 데이터로 가져왔을 때 네트워킹 이후의 UI를 보기 위해 di해줄수 있다.

프론트 친구들에게 스토리북을 물어보자


디버깅 A to Z print,  실전 Flutter 개발 꿀팁 - 송승헌

플러터에서 디버깅하기

버그란 무엇일까?

실행하는데 방해가 되는 무언가 = 버그

디버깅 = 버그의 원인을 찾아내고 수정하는 과정

작동하기를 원하는 기댓값을 적어두 테스트를 진행


print(), kdebug, logger를 주로 디버깅할때 사용함

print를 주의해서 써야 하는 이유는 앱을 출시해도 콘솔에 찍을 수 있음

api 테스트로 print를 사용하면 그대로 노출될 수도 있다.

플러터는 debug, profile, release 3가지의 빌드 종류가 있음

디버그 모드에서만 로깅이 가능함

kdebug를 사용하면 디버그 모드일 때만 프린트 문이 찍힌다.

if (debug) {실행문}

안드로이드는 콘솔창에 메시지가 빠르게 지나갈 경우 없애려고 함
이를 방지하기 위해 debugPrint를 사용함

profile과 release에서도 ㅆㄱㄴ

“dart:developer”

log 함수를 사용할것

로그의 중요도, 시간, 추적 기능을 지원해준다.

브레이크 포인트를 강제로 만들어주는게 디버거

when으로 종료 시점을 명시하고, message에 메시지를 지정한다.

API 호출시간을 프린트문 두개로 측정해서 빼주는게 아니라

시작과 끝을 상태를 명시해줘서 측정할 수 있다.

logging 시스템은 왜 사용할까?

메시지 외에도 메타데이터를 포함하여 로그를 분석
에러 정보와 스택 추적을 통해 효과적인 디버깅을 지원
다양한 로깅 도구와 통합하여 로그를 관리
사용자 정보 추적 및 데이터 저장, 관리

logger라는 패키지도 있음

콘솔을 좀 더 눈에 잘 보이도록 해줌

pretty_dio_logger : 네트워크 요청을 좀 더 이쁘게 해줌




dev tools <<== 이거 개좋음 꼭쓰셈

위젯을 가지고 테스트가 가능함

UI 디버깅을 할 수 있다.

레이아웃에 에러가 났을때는 코드부터 만지지 말고 Inspector부터 먼저 보자

빌드 중 뭐 몇초에는 이게 나왔다 하면서 타임라인을 제공해줌






네이티브를 위한 디버그 툴

디버깅 하면서 했던 경험








Flutter 라이브러리 톺아보기 - 조새벽

라이브러리 : 특정 작업에 초점을 맞춘 컬렉션
패키지 : 다양한 주제를 다루는 여러 라이브러리 모음집

공식 라이브러리, 커스텀 라이브러리, 써드파티 라이브러리

라이브러리를 사용하는 이유

코드 재사용성, 커뮤니티 기여, 상호 운용성 및 표준화, 모듈성 및 유지 보수성, 신속한 개발, 비용 효율성

awesome 으로 검색하면 좋은게 있다

라이브러리 유형과 추천

UI 라이브러리

flutter_svg : svg 파일을 렌더링할때 사용함

flutter_screenutil

responsive framework

애니메이션 라이브러리:

animations

animated Text Kit


네트워킹 라이브러리:
 
http 

dio

graphql flutter

상태 관리 라이브러리 :

provider

riverpod

bloc

get

지속성 라이브러리:

shared_preferences

path_provider

flutter secure storage

이미지 처리 라이브러리:

image picker

flutter image compress

photo view

네비게이션 라이브러리:

url launcher




Flutter 클린아키텍처 - 양수장



클린 아키텍처 : 유용하고 효율적인 앱을 만드는 방법 == 계층을 나누는 것

프레임워크와 드라이버 계층 : UI, 웹 프레임워크, db 및 기타 외부 시스템과 같은 외부 문제를 처리하는 바깥쪽 계층

프레임워크 : UI 컴포넌트, 라우팅

드라이버 : 데이터 소스, 리포지토리 구현체, 플랫폼 특화 코드



인터페이스 어댑터 계층: 도메인 계층의 상위 비즈니스 규칙과 프레임워크와 드라이버 계층의 외부 관심사 사이의 가교 역할



모든 뷰를 그리는 로직과 관련된 부분이 뷰에 존재해서는 안된다

상태관리 라이브러리를 사용해서 함

가장 많이 쓰는게 Provider, 리버팟, 블록, getX

사용자가 특정 액션을 하게 되면 특정 상태로 변환하게 됨

UI에서는 그 상태에 따른 UI를 선언만 하면 끝


유저 <-> 위젯 <-> 상태관리 <-> 유스케이스 <-> 데이터 레포지토리 <-> 데이터 소스

인터페이스를 통해서 종속성 주입이 ㄱㄴ

계층별로의 권한을 분리

유스케이스를 사용자의 액션으로 기준

유스케이스에 대해서는 좀 논란이 많ㅇ긴 함;;

어디까지를 유스케이스로 봐야하는지, 꼭 필요한지.

굳이 왜 유스케이스를 써서 보일러플레이트를 감소하면서까지 쓰는가

비즈니스 로직을 유스케이스에 위치시킴으로써 로직을 한군데로 모으는 느낌

Mapper를 통해서 엔티티로 변환함


git.it만드로는 조금 불안할 수 있음


어노테이션을 통해서 관리 할 수 있음
