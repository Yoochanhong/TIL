# Go To Daejeon 2023

## Vector Database? you had me at go - 박진형

벡터 : 단 하나의 숫자로 나타낼 수 없는 양

기계학습 분야에서는 모델 학습을 위해 사용하는 데이터나 가중치, 모델의 결과값으로 나타는 값 == 모두 벡터로 취급

차원도 벡터와 연관지어서 생각할 수 있음

3개의 벡터값을 가지는 벡터는 3차원벡터

N개는 N차원 벡터

차원을 더 늘릴경우 필요한 데이터는 기하급수적으로 늘어남

각각 특징 변수를 추가할수록 그에 맞는 정보를 제공해야 함을 의미하고,

큰 차원엔 그에 맞는 큰 데이터를, 작은 차원도 역시 그에 맞게 상대적으로 적은 데이터를 제공해야 함

- 1600 x 900보다 1920 x 1080 모니터가 더 선명한 이유

임베딩 : 고차원의 데이터를 저차원으로 매핑하면서, 그 의미를 보존하는 것

고차원의 데이터를 저차원으로 매핑한다는 것은 높은 차원의 벡터를 낮은 차원의 벡터로 변환한다는 뜻일 것이다

- 불필요한 정보를 제거한다 정도..?

PCA 차원 축소

Pinecone

카드사의 정보를 조회하는 고객센터 대용

앱에서 카드대출한도 정보를 요청할 때,

신용 등 이것저것 다 합치면 고려할 게 많다

표본모델을 content라고 생각하고, 앱에서 쿼리를 임베딩 모델에 날림 (content도 날림)

query와 content 사이의 연관성을 찾고, 가까운 거리에 있는 정보를 가져와서 벡터 db에 저장함

Vectors → indexing → vector db → querying → post processing

인덱싱 과정은 ANN HNSW알고리즘을 사용해 정확도의 수준을 최대로 높임

Milvus 개좋ㅎ음(go로 만들ㅇ렀음)

## Tune Go’s Runtime Knobs with automaxprocs & automemlimit - 김건

### Runtime Knobs

자바에는 많은 런타임 에러들이 있다

런타임 노브를 추가하게 되면 걔를 모든 케이스에서 관리해야 한다.

테스트해야 할 양이 기하급수적으로 늘어남

Go는 5개;

런타임 노브들을 최대한 적게

runtime.GOMAXPROCS

SetGCPercent

SetMemoryLimit

노브를 튜닝하는게 정말 중요할까?

그랩 : gomaxprocs에서 잘못된 걸 튜닝했더니 성능이 좋아짐

우버 : setGCPercent 잘 고쳤더니 돈 아꼈다

### Tune Scheduler

스케줄러가 어떻게 동작할까

머신 스레드와 고루틴을 잘 매핑함 (Go 1.0)

GoMaxProcs == 최대 실행 가능한 active thread의 수

1.0에는 최대 1개의 스레드만 돌 수 있었다

1.1에 좀 바뀌게 되는데

로지컬 프로세서 (P)

P가 코어의 역할을 로지컬한 부분에서 담당

local run queue를 만들어서 따로 사용

P 하나마다 머신 스레드가 하나씩 달림

그렇다면 GOMAXPROCS == 로지컬 프로세스의 수 로 바뀌게 됨

1.5부터는 기본값이 코어수 == 고맥스프로스가 됨

이론적으로 가장 좋은 성능

고맥스프로스 > cpu

쓰로틀링 발생

그만큼 다양한 프로세스들이 많아서 문맥교환이 잦아짐

동시에 실행될 수 있는 고루틴의 수도 증가해서 락 컨텐션이 증가

캐시 인벨리데이션

어떤 cpu에서 로지컬 프로세서가 돌지 모름

반대 :

병렬처리를 못함

IDLE 코어가 생김

일반적으로 컨테이너 환경에서 다양한 아이들을 사용함

16코어라도 3코어를 할당하면 3코어임

근데 문제는 고는 이걸 몰라서 할당한 양보다 더 많이 사용할 수 있음

우버에서 라이브러리를 만들었음

import만 해주면 알잘딱으로 할당한 만큼 런타임에서 cpu 코어갯수를 잡아줌

### Tune Garbage collector

가비지 컬렉터가 cpu와 메모리에 어떤 영향을 미칠까

메모리 코스트 = 힙 메모리 총량 + GC가 돌고 새로 생긴 메모리의 총량 + 약간의 메타데이터

하드리밋의 50%을 GC를 설정했을때(너무 크게 잡았을 때), 메모리 자원을 넘겨서 죽어버릴수도 있음

GC 사이클이 너무 많으면(너무 작게 잡았을 때) 프로그램의 레이턴시가 증가

- 순간적인 대용량 트래픽에 취약

적당량의 GC 값을 찾는 방법은 뭘까?

우버가 이걸 해결

하드리밋 아래로 GC 선을 잡고, 넘을것 같으면 GC 가동 후 다시 자동으로 GC 계산

## Object Oriented Go - 정진우

메인 & 사이드 프로젝트 모두 Go로 짜는중

그치만 다른 경험이 더 많고, OOP도 자바로 공부함

OOP 맥락에서 Go를 어떻게 사용해야할까 발표하기로 함

### OOP

객체지향 프로그래밍이란? - 이거 사람마다 좀 다르다고 함

그치만 한문장에 너무 많은 의미를 담으려고 함

객체에 메시지를 전달하는 방식으로 비즈니스 로직을 구현하는 것

- OOP의 핵심은 Message Passing
- 프로그램 전체에 OOP를 강제하는 것이 아님

### Message Passing

프로그램 내에 다양한 객체들이 존재할 때, 서로 통신하기 위한 수단

수신한 메시지는 본인만의 메소드로 처리

데이터 중심으로 보기보단 객체 중심으로 할것

객체의 메소드를 호출해서 처리할 것

Go는 클래스가 없지만 인스턴스는 객체로서 활용이 가능하다

### Encapsulation

구현을 외부로부터 감추는 것 == 캡슐화

퍼블릭 메소드로만 프라이빗 필드로 접근하도록 행동을 강제하는것

Go는 패키지 수준에서만 캡슐화를 제공한다

문제 1 : 내부구현 노출

- 멤버 구조체의 내부 구현을 자유롭게 설정 및 수정 가능

퍼블릭 인터페이스로 내부 구현을 숨김

문제 2 : 초기값이 비어있는 인스턴스

- 생성 시점에 내부 구현을 자유롭게 지정하는 것은 불가

생성자 함수를 제공

구조체를 프라이빗으로 만들고 퍼블릭 인터페이스를 만들기

개쩜

이거 써먹어야 할듯

### Inheritance & Composition

상속은 서브타이핑과 서브클래싱 두가지 용도로 사용할 수 있다

서브클래스가 슈퍼클래스를 대체할 수 있을 경우 서브타이핑이라 부름

반대는 서브클래싱

코드 재사용은 상속보다는 객체 합성이(조합) 더 좋은 방법

리스토프 치환 원칙 위배됨

서브클래싱하지 말고 서브타이핑하기

문법적으로 List를 상속받으면 List로 업캐스팅 ㄱㄴ

스택에서 큐 메소드들까지 사용 가능성이 생김

조합을 사용하면 List를 숨기고,  has-a 관계를 사용해서 list의 메소드를 내부적으로 호출

필수적인 메소드들만 정의해서 사용하면 안정적으로 보장함

외부에서는 신뢰하면서 사용할 수 있음

스택에는 큐의 메소드가 존재할 수 없기 때문에

Go는 상속이 없음

타입 내부에 다른 타입을 포함시켜서 서브클래싱과 유사하게 사용가능

정리

- 자바에서 코드 재사용 목적으로는 상속 대신 조합

### Abstraction & Polymorphism

의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법 == 추상화

추상화만 캐피지 외부에 노출

내부 구현은 패키지 수준에서 캡슐화

서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메소드를 이용해 메시지를 처리하는것 == 다형성

추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있을 것

자바는 상속을 통해 다형성이 가능함

객체지향에서 말하는 올바른 상속의 사용법

Go는 인터페이스를 쓰는것만이 다형성을 구현하는 방법

추상화 & 다형성을 활용하는곳 : 개방 폐쇄 원칙

추상화에 대한 의존

인터페이스를 의존하고 있기 때문에 영속성 스택이나 인메모리 스택이 필요하면 걍 갖다 박으면됨

의존성 역전 원칙

상위 모듈이 하위 모듈의 구현에 의존하지 말것

별도로 구현된 추상화에 의존하기

근데 Go는 의존성 역전이라 부르기 좀 애매함

DIP 해버리면 걍 의존성이 끊겨버림

인터페이스 분리원칙

있을 것만 딱 있을 것

호출하면 안되는 메소드의 존재 자체가 위험함

ISP하면 안전하게 인터페이스를 사용할 수 있음!

### 결론

Go는 객체지향적인가? 에 대한 논란의 여지는 있음

다만 OOP 개념 및 이론은 적용할수 있다는 점

OOP는 프로그래밍 패러다임일 뿐

사고의 확장을 위한 지침이지 OOP에 매몰되서는 안됨

- 객체지향적이기 떄문에 좋은 코드이다 (X)
- 객체지향 이론을 적재적소로 적용했더니 구조가 개선되었다(O)

OOP를 적용하는데 필수적인 문법을 충분히 제공 ⇒ Go는 충분히 객체지향적이다

## Go 언어의 경량 스레드와 speech recognition으로 영어 읽기 교육 서비스 구축하기 - 한성민

### Go 소개하기

- 고루틴을 이용한 경량 스레드 사용 가능 # 코어가 많을수록 빠름
- 학습 진입장벽이 낮음 # 적은 문법 키워드 # 직관적인 문법 구조
- 컴파일 속도가 매우매우 빠름!
- 빠른 런타임 성능

### overview

키워드 스팟팅이 꼭 필요한가?

자연발화에서는 어떤 일이 발생할지 모른다

오케이 구글! 이라고 키워들 말함으로써 이 상황에만 동작하도록 유도 → 돈 아낌

### keyword spotting(KWS)

파장데이터로 이루어져있는 음성 데이터를 kws를 이용해 특정한 단어나 패턴이 인식되면 시그널을 줌

트리거 해주는 아이

### speech Recognition

음성데이터를 고루틴을 활용해 텍스트로 바꾸는 과정

### prompt Engineering

모델의 행동 강령을 작성하는 과정

### Speech Synthesis

텍스트를 목소리로 만드는 과정

### 결론

Go는 실시간 음성 처리에 유용하다

다이얼로그 작성이 너무 쉬워졌다.

### 질문

혹시  kws를 하고 대화형식으로 굳이 한번 더 키워드를 언급하지 않아도 대화가 가능하냐

ㅆㄱㄴ 실제로 클로바는 이렇게 한다고 함

## OpenAPI 안편해요? - Container App 배포기 - 임미르

음,,, 잘 모르겠음

어떤걸 발표하고싶으신건지 내가 의미파악을 잘 못함

## LLM  101: 챗봇 빌딩 말고도 할 수 있는 언어모델(LM) BM

### Lage Language Model, LLM이란?

- 초거대 언어 모델이란 통상적으로 100B 이상의 파라미터를 가지고 있는 언어 모델을 지칭함
- GPT -4로 대표되는 LLM은 이미 다양한 분야에서 추가적인 학습 없이도 인간 이상의 성능을 보여줌
- 비용, 보안, 성능의 이슈로 곧바로 서비스하기엔 문제가 있음

### 최적화된 언어 모델은 LLM을 뛰어넘을 수 있을까?

- 특정 세부 과제에서는 LLM 이상의 성능을 보인다는 연구 결과가 보고되는중

### 한국의 초거대 모델의 발전 상황

- 네이버의 하이퍼클로바, 일루더API의 폴리글랏, 카카오의 KoGPT가 공개되어있는 유일한 한국어 모델
- 언어 모델을 만들기 위해 필요한 학습 데이터의 양, 모델 파라미터의 수, 하드웨어 성능은 빠른 속도로 증가하고 있음 → 대기업도 감당하기 힘든 수준에 도달할정도
- GPT - 4 한번 학습시키는데 추정치 약 2600억
- 7~40B 파라미터를 가진 언어모델을 최적화하는데 필요한 토큰 수는 1
    - 네이버가 2021년 82B 모델을 학습시키는데 쓴 토큰은 0.56
- 국내에서 가장 우수한 연구수준을 가지고 있는 네이버도 해외 기업의 scale-up 속도를 따라가는데 어려움을 겪고 있음

### 그렇다면 한국어 언어 모델을 사용해 서비스를 제공하기 위해서는 어떻게 해야 할까?

- GPT, 클러버 X같은 LLM을 만든다
    - OpenAI가 7140억 적자라고 함
    - 아무리봐도 손해
- 비용을 감수하고 GPT - 4를 사용한다
    - 플러그인 전쟁
    - 과연 GPT - 4 가격이 얼마나 할까?
        - 1쿼리당 4는 400원, 3.5는 35원
        - 너무 비싸다
    - 챗지피티에서 유료로 GPT - 4를 쓰지 않는 유저를 모을 수 있는 전략
    - 근데 비용이 만만치 않음
- 작은 언어 모델을 서비스에 맞게 최적화 해서 사용한다
    - 현실적으로 스타트업이 선택할 수 있는 유일한 전략
    - 가장 활발히 연구가 이루어지고 있는 분야
    - Domain Specific한 질문에 LLM이 답을 잘 못함
        - 개체명 인식기, Domain Specific한 토크나이저부터 개발해야 하는 단계

### 그래서 생성형 언어모델로 어떻게 돈을 벌어야 할까

이미 대중화되기 전 NLP로 돈을 벌고 있던 기업들

- Verbit
    - 음성을 텍스트로 변환해주는 회사
- Fiscal Note
    - 자기가 원하는 정책이나 법안을 통과하도록 도와주는 회사
- Fractal Analytics
    
    

**결국은 독점적인 데이터를 쓰는 곳이 돈을 더 잘 벌게 한다는걸 알려준 회사들**

Domain Specific 한글 언어 모델 개발과 기업이 돈을 벌 수 있는 ‘컨텐츠’를 생성하는 것이 돈을 벌수 있는 방법

중요한것은 언어모델보다 얼마나 데이터를 유기적으로 잘 만들어놓고 리트리버 할수 있느냐의 문제

## Fireside chat 질문용

Q : 정진우님이 Go로 서버를 짠다고 발표하셔서 질문드리려고 합니다

orm 관련해서 질문해보려고 합니다.

Go에 목적? 키워드는 빠른 컴파일, 간단한 문법, 가벼움이라고 알고 있습니다

하지만 런타임에 타입을 추론하는 orm같은 애는 정적타입 언어인 Go의 장점을 해치는게 아닌가 생각합니다

이걸 몰랐을때는 저도 gorm 쓰고 xorm 쓰고 그랬는데 알고 아니까 안쓰게 되더라구요

저는 이념때문에라도 sql문을 쌩으로 짜지만 회사의 경우에는 아무래도 이득적인 면을 더 볼거라고 생각을 하는데, 혹시 회사에서는 Go 관련된 orm을 사용하는지 궁금합니다

A : 일단 서버가 여러개다

내부에서 작업할떄는 성능 안따지니까 orm 쓰고, 성능이 필요한곳은 orm을 쓰지 않는다

하나 고치면 다 가지니까 쿼리 자체를 추가할떄는 진짜 조심하고 신중한 편

비즈니스 로직을 구현할때는 의외로 쿼리를 수정하지 않을 떄가 많음

본인은 소프트웨어 마이스터고에 다니고 있다.

지금 2학년이고 아마 곧있으면 취업을 준비해야 하는데, 대학 진ㅇ학을 고민중이다

혹시 회사 다니면서 고졸 개발자와 대졸 개발자의 대우에 대한 차별을 겪었거나 본 적이 있는지 궁금함
